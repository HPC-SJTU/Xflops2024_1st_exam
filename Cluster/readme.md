## 题目描述

李华不懂超算，但是他一直有搭超算的梦想。

在李华的眼里，超算是由一个个的服务器上下叠落而成的，但由一些物理常识可以知道，如果服务器堆得过高，过重就会导致整个集群坍塌。

李华也知道这点，于是他仔细地测量了每台服务器的承重能力 $c_i$ 和自身重量 $w_i$ ，并定义一个服务器的风险值为其上方所有的服务器重量之和减去其自身的承重能力，而一个超算集群坍塌的风险则为集群中风险值最大服务器的风险值。

显然，合理的摆放服务器可以减小超算集群坍塌的风险。现在李华希望知道对于给定的服务器参数，在所有摆放方案中超算集群坍塌风险的最小值是多少。

李华尝试穷举所有的排列方案以计算最小值，但是他发现这样做复杂度达到了惊人的 $O(n!)$ ，李华顿时束手无策，便把这个问题交给了你。

你看在李华这次承诺不再需要你为他撰写一封收件人是你自己的感谢信的份上，决定帮他这个忙。

## 你的任务

请你修改`solver.hpp`文件中的`solve`函数，使其输出当前服务器参数下超算集群坍塌风险的最小值。

函数输入参数：
* `Server *servers`：Server类型的数组，每个Server表示一台服务器，Server结构体中`weight`数据成员即为服务器的自身重量 $w_i$ ，`capactiy`数据成员即为承重能力 $c_i$ 。
* `long long n`：`servers`数组长度 

函数返回值：
* 在所有排列方案中超算集群坍塌风险的最小值

数据规模：
对于100%的Server, $w_i$ < min{1e6, n}, $c_i$ < min{1e12, n}

为方便大家测试，我们提供的`main.cpp`中提供了并行的随机数生成代码，并且其符合数据规模要求。同时给出了对应的正确答案供大家校验。但是我们**并不保证**最终的评测使用`main.cpp`中一致的随机数生成器。

**请注意，你只能修改solver.hpp文件**

HINT: 本题的解题方法类似 NOIP 2012 国王的游戏，如果完全没有思路可自行搜索参考此题

## 示例

服务器数据：这里第一行表示服务器数目（即函数的输入参数`n`），剩下每行代表输入的每台服务器的承重能力 $c_i$ 和自身重量 $w_i$ 。

```
3
3 10
5 2
3 3
```
`solve`函数的返回值：
```
2
```

## 运行方法

先使用下述命令加载编译器环境，设置openmp默认线程数量并绑定openmp每个线程到一个核心上运行
```
source env.sh
```

然后使用下述命令进行编译
```
make
```

最后使用下述命令运行可执行程序
```
./cluster <conf_file_name>
```
运行完成后将输出用时（单位：s）和你的答案。

## 评分方式

本部分需要你提交**slover.hpp**文件，我们将会使用你的`slover.hpp`替换初始的文件并先运行`source env.sh`加载环境，再运行`make`编译得到可执行文件并对五个算例进行测试。每个算例测试前会先warm up一次，之后重复运行五次，取五次运行的平均时间作为该算例的最终运行时长。

每个算例在结果正确的情况下会依据性能进行评分：

$$ score = min(20, 20 * \frac{time_{zero} - time}{time_{zero} - time_{full}}) $$

算例规模与时间要求：
| 算例规模 | 占比 | 满分时间| 零分时间
-----|------|----|----
1e1  | 10% | 1s |1.001s
1e5 | 10% | 1s |1.001s
5e5 | 10% | 1s |1.001s
5e8 | 35% | 25s | 60s
1e9 | 35% | 50s | 110s


你的最终成绩即为所有算例得分之和。

**评测脚本**
我们提供了`evaluate.py`用于自测你当前的答题情况。直接运行
``` bash
source env.sh # 请在运行脚本前先加载环境
python evaluate.py
```
将对你目前的答案进行评测，并输出你的得分。

对于第一题（性能优化题）默认情况下将会按照最终的评测标准进行测试，这将会让每个算例运行6次。如果你希望测试过程更快，可以添加参数`-t <num>`使得程序只会在warm up后运行`<num>`次，如果你希望不进行warm up，可以添加参数`--no-warmup`。但这都将导致结果可能不如最终评测准确。
例如
``` bash
python evaluate.py -t 1  # 在warm up后只运行一次算例
python evaluate.py --no-warmup -t 1  -c 1 # 不进行warm up，只运行一次算例
```

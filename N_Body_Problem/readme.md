# N体问题模拟器

### 题目背景：天体模拟与计算优化

在天体物理学中，N 体问题是研究天体相互引力作用的经典问题。它描述了由 N 个粒子（例如星系、恒星或其他天体）组成的系统的动力学行为。粒子间通过引力相互作用，根据牛顿的万有引力定律，影响其他粒子的运动。

想必“二体问题”大家都已经非常熟悉了，即两颗星体相互环绕，这是可以通过解析手段解决的问题。而到了三体的世界，体系出现了混沌现象。三体问题是指在引力作用下，求解三个粒子系统的运动轨迹的问题。这一问题没有解析解，因此通常需要使用数值方法进行计算。三体问题的一个显著特征是其行为的高度敏感性，即小的初始条件变化可能导致系统行为的显著差异，这被称为“混沌现象”。这种混沌行为使得三体系统的长期预测非常困难，是天体物理研究中的一个重要课题。今天我们要优化一个N体问题的模拟器。

### 问题描述

你需要优化一个 N 体问题模拟器，该模拟器能够计算和预测粒子在引力作用下的运动轨迹（不考虑碰撞）。你的任务是基于以下要求对模拟器进行优化和验证：

1. **基本功能**：

    - 题目给出的软件是一个朴素实现的模拟系统，其中包含 N 个粒子，每次迭代计算各自的速度和位置。
    - 每个粒子有位置、速度和质量基本属性。
    - 使用牛顿万有引力定律计算粒子之间的引力，并更新粒子的速度和位置。
    - 题目中初始化的数值与实际天体相去甚远，本程序重点在于优化模拟运算过程，与实际情况在数值上不符合是必然的。

2. **并行化优化**：

    - 请使用 OpenMP 和 MPI 对现有的串行代码进行并行化优化。目标是提高计算效率和减少模拟所需的时间。
    - OpenMP版本的代码需要在nbody_omp.c代码中修改优化，这个文件最初是与nbody_serial.c完全相同的。
    - MPI版本代码与原始版本差别较大，所以已经给出基本框架。本题的MPI部分需要你补全nbody_simulator_mpi.c中所有的TODO之后的MPI通信语句。

3. **正确性校验**：

    - 本题的检查分为**动量能量守恒的检查机制**与**位置坐标检查机制**。
    - 动量和能量的总量应该在模拟过程中保持不变（在数值误差范围内）。
    - 定期输出系统的总动量和总能量，并验证其守恒性，同时记录下特定星体的坐标，并与文件夹中*.ref文件中记录的串行版本数据比较。
    - 只有动量能量守恒与位置坐标都通过检验才算正确性通过。
    > hint：多体问题为混沌系统，任何初值的微小变化都可能导致结果出现极大的变化，请注意你在优化时使用的变换是否误差可接受。例如：对于浮点数加法来说，运用结合律将导致误差。

4. **文件说明**

    -   Makefile：编译所需文件，初始版本是能成功编译各个版本代码的，编译选项可以修改，具体编译方法见下文。**可以修改编译选项**。
    -   Makeflag: 编译选项提交文件。在该文件的第一行写入你希望使用的编译选项，我们将在评测时用你的编译选项替换掉初始Makefile的编译选项。**可以修改**。
    -   nbody.h：头文件，其中包含宏定义和函数声明，**一定不可修改**。
    -   main.c：程序的驱动文件，其中实现了系统初始化、迭代并调用模拟运行函数、计时、正确性检验等内容，**一定不可修改**。
    -   nbody_serial.c：最原始串行版本的软件，他的运行性能被称作benchmark/baseline（基准），本文将不作最终测评成绩用。**一定不可修改**。
    -   nbody_omp.c：在你刚拿到这道题时，他和nbody_serial.c是完全一样的。我们对你OpenMP部分的优化的测评结果就基于这个文件，**尽情发挥你的聪明才智修改它吧**。
    -   nbody_simulator_mpi.c：已经改好的mpi框架程序，但是mpi通信语句没有实现，请补全所有TODO处的通信语句，使整个程序运行起来。本文件只作为自测调试用，MPI部分得分不根据这个文件的运行成果。**请只在TODO之后添加代码，不要动其他部分**。
    -   my_mpi_comm.txt：本文件需要你填入你在nbody_simulator_mpi.c中补充的mpi通信语句，填在每个TODO下方即可，我们会根据这个文件对你的MPI部分给分。**请按要求修改**。
    -   ref_data/ ：该文件夹下为正确性校验文件。**一定不可修改**。
    -   另：串行版本与OpenMP版本的代码是基于nbody.h、main.c、nbody_serial/omp.c分别三个文件运行的，而MPI部分的测试只依赖于nbody_simulator_mpi.c文件运行。

5. **编译运行**

    -   性能优化部分（omp部分）有3种大小的算例，分别是粒子数N=1024、4096、8192，每个大小有5个不同的平行算例（初始化不同）具体如下：

         ```bash
         module load bisheng/2.5.0 #加载编译器环境
         make #编译串行版本，要是成功运行了你应该会得到一个nbody_simulator_serial可执行文件
         make omp #编译并行版本，要是成功运行了你应该会得到一个nbody_simulator_omp可执行文件
         
         ./nbody_simulator_serial ref_data/1024_1.ref #运行串行版本的1024粒子程序，随机数种子为1
         ./nbody_simulator_serial ref_data/4096_2.ref #运行串行版本的4096粒子程序，随机数种子为2
         ./nbody_simulator_serial ref_data/8192_3.ref #运行串行版本的8192粒子程序，随机数种子为3
         
         ./nbody_simulator_omp ref_data/1024_1.ref #运行omp并行版本的1024粒子程序，随机数种子为1
         ./nbody_simulator_omp ref_data/4096_2.ref #运行omp并行版本的4096粒子程序，随机数种子为2
         ./nbody_simulator_omp ref_data/8192_3.ref #运行omp并行版本的8192粒子程序，随机数种子为3
         ```

     -   以最终输出的“total simulation ends in %f sec”的数值作为唯一评分依据。

     -   代码补充部分（MPI部分）编译运行命令如下：

         ```bash
         module load openmpi/4.0.3-gcc-10.3.1 #你需要加载openmpi才能在命令行中执行mpicc与mpirun等语句，如果出现make: mpicc: No such file or directory这种报错那很有可能是你忘了加载他。
         make mpi                           #这句话是编译语句，要是成功运行了你应该会得到一个nbody_simulator_mpi可执行文件
         mpirun -n 128 ./nbody_simulator_mpi
         ```


### 评分方式：

本题目共100分，分为性能优化部分（60）和代码补充部分（40）。

本部分需要你提交**Makeflag**, **nbody_omp.c**, **my_mpi_comm.txt**三个文件。

1.   **性能优化部分（60分）**

     该部分将使用`Makeflag`与`nbody_omp.c`进行评分。我们将先使用你的`Makeflag`文件的编译选项替换掉初始`Makefile`文件的编译选项。然后使用`make omp`编译得到可执行文件并对三个算例进行测试。每个算例测试前会先warm up一次，之后重复运行五次。由于集群上存在性能波动，我们将取重复运行五次中的时间最短的三次的调和平均值作为你最终的成绩。
     
     你的可执行程序将会运行在比赛集群上的一台机器的**128个核心**上，限制内存占用为**256G**。

     -   算例得分安排如下：本题目采用插值得分方式，按照输出的时间对数插值得对应的分数。

         | 算例规模 | 零分时间   | 满分时间       |
         | -------- | ---------- | ---------- |
         | N = 1024 | 30s   | 3.0s |
         | N = 4096 | 360s  | 6.0s |
         | N = 8192 | 360s  | 20.0s  |

         得分计算方式如下

         $$
         算例的得分=算例的满分 * \min(\max(\frac{\ln(你的运行时间)-\ln(零分时间)}{\ln(满分时间)-\ln(零分时间)},1),0)
         $$
         

2.   **代码补充部分（40分）**

     该部分将使用`my_mpi_comm.txt`进行评分。我们将规范化你所填的答案，以避免空格空行或一些等价的变换导致评测出错。最后将规范化的答案的sha3-512哈希值与标准答案对比进行计分。

     -   本题有3处TODO，分数按10分、15分、15分依次分配。

     -   请在源文件中补充代码自行调试，**同时将你补充的代码填在my_mpi_comm.txt中对应TODO的下方空行**，每条C代码写一行，注意结尾分号。

     -   本题会根据你的my_mpi_comm.txt文件而打分。

     -   本题没有计时要求，如果能正确运行，应该30s以内能运行完。此时你会看到“CONGRATULATIONS, YOU DID IT!”。

     -   格式特殊要求：
     1. 前两个通信语句需要传输自定义结构体类型，请使用MPI_BYTE数据类型按Byte传输，结构体大小可用sizeof(结构体名称)获取。
     2. 填写语句时每个输入变量中至多只能包含一个数学运算符（限定：+, - ,* , /）。
     3. 一条语句必须写成一行，一行之内只能有一条语句。即不要把一条语句写拆写成几行，也不要把多条语句写在同一行。
     4. 请不要在语句中添加任何注释。变量名请参考nbody_simulator_mpi.c中声明，不要改变量名。
     5. 请不要修改TODO行的任何内容。

     -   无需担心语句中有交换律的运算、四次归约语句的顺序、语句内的空格和语句间的空行等格式问题。

**评测脚本**
我们提供了`evaluate.py`用于自测你当前的答题情况。直接运行
``` bash
python evaluate.py
```
将对你目前的答案进行评测，并输出你的得分。

如果你希望只评测一道题，可以使用`-c`指定测试的题目。例如:
``` bash
python evaluate.py -c 1 # 只测试第一题
python evaluate.py -c 2 # 只测试第二题
```

对于第一题（性能优化题）默认情况下将会按照最终的评测标准进行测试，这将会让每个算例运行6次。如果你希望测试过程更快，可以添加参数`-t <num>`使得程序只会在warm up后运行`<num>`次，如果你希望不进行warm up，可以添加参数`--no-warmup`。但这都将导致结果可能不如最终评测准确。
例如
``` bash
python evaluate.py -t 1  # 在warm up后只运行一次算例(由于没有指定-c，评测完第一题后同时也会评测第二题)
python evaluate.py --no-warmup -t 1  -c 1 # 不进行warm up，只运行一次算例(同时也只评测第一题)
```

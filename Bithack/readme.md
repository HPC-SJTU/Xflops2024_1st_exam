# Bithack

## 简要介绍

本题目为你提供了一个学习如何使用 perf 工具提高程序性能的机会，并实验 bit level 的并行：将 byte 抽象为一个 bit vector，可以在其上执行位运算和逻辑运算。  

通常，当你关心程序的性能时，最好的方法是先实现一些正确的东西，然后对其进行评估。在某些情况下，这个初始实现中的许多部分（甚至整个实现）可能已经足够满足你的需求。然而，当你需要提高性能时，你必须首先决定在哪里集中你的努力。这就是 profiling 派上用场的地方。profiling 可以帮助你识别程序中的性能瓶颈。  

## 代码结构

代码位于 source_code/everybit 目录中。请你先查看 bit_vector.h 和 bit_vector.c 文件。这段代码实现了分配、访问和处理大量位字符串所需的功能，同时使用最少的内存。在实现中，bits 在内存中每 8 位打包成一个字节，但可以通过函数 bit_vector_get() 和 bit_vector_set() 单独访问。 

你的任务是改进 submit_func.c 文件中的 rotate_the_bit_vector() 函数。完成任务时，不要在你的实现中调用 bit_vector_new() 。你可以在栈或 BSS 段（例如，全局数组）中分配小缓冲区。  

如果你的 rotate_the_bit_vector() 函数的实现通过 bit_vector_get_bit_sz() 和 bit_vector_get() 访问 bit 数组的内容与运行原始的、慢速的实现后的内容相同，则认为你的实现是正确的。  

计时和测试系统位于 main.c 和 tests.c 中，它们会调用你的代码。不要修改这两个文件，我们运行你的代码时会将它们替换为新的副本。同样地，不要移除或更改 main.c 或 tests.c 调用的任何函数的签名。简而言之，提供的文件 main.c 和 tests.c 应该始终能与你的代码一起编译并正确执行！  

## 构建代码  

请你先配置编译器环境。 在比赛提供的集群上， 请使用 `module load  bisheng/2.5.0` 加载 bisheng 编译器。 

接着， 你可以通过输入 make 来构建代码。输入 make DEBUG=1 可以构建带有调试符号的代码，这在使用 gdb 调试时很有用。everybit 二进制文件接受参数，允许你运行由长时间运行的位旋转操作组成的基准测试，运行给定测试文件中的所有测试，以及运行测试文件中的特定测试。有关使用说明，你可以运行

```shell
$ ./everybit
```

用法：

```shell
./everybit
-s 运行一个示例短时间（0.01秒）旋转操作
-m 运行一个示例中等时间（0.1秒）旋转操作
-l 运行一个示例长时间（1秒）旋转操作
-t tests/default 运行测试文件tests/default中的所有测试
-n 1 -t tests/default 运行测试文件tests/default中的测试1
```

## 性能测试

你可以使用以下命令运行一个示例基准测试

```
./everybit -l
```

./everybit -s, -m, 和 -l 选项运行不同长度的基准测试。每个基准测试几何级增加旋转位的数量，直到你的算法超过某个特定阈值（-s 为0.01秒，-m 为0.1秒，-l 为1秒）。我们将根据对你尚未开放的独特算例来评分你的性能。  

朴素的长时间运行版本不会完成很多等级。但简单的优化应该能让你的旋转代码完成更高的等级。

## 正确性测试  

你可以采用以下方法自测你的代码：

### 小样本

你可以使用以下命令运行tests目录中的所有测试文件

```
$ make test
```

你也可以运行命令

```
$ make testquiet
```

这将运行所有测试，但仅输出失败测试的信息

### 大样本

使用小样本的方式测试的较长的位字符串较为麻烦，如果你希望测试比较长的位字符串，可采用 `source_code/check_example` 中的测试脚本，测试流程如下：

1. 将你的`submit_func.c`放置在`check_example`文件夹中
2. 将`parameter.h`中的参数设置为你希望测试的算例的参数
3. 运行`make`即可进行测试，如果`make`命令未报错则表明测试通过（更准确的说，`make`命令返回值为0即为测试通过）
    * Tips：命令`echo $?`将会输出命令行中运行的上一个命令的返回值。 

## 目标函数

函数 rotate_the_bit_vector() 将位数组中的位字符串向左或向右旋转某个数量。请参阅 bit_vector.h 中的文档。最初的原型函数很慢，它执行了大量的单一位旋转，一遍又一遍，直到达到正确的旋转度数。如果你尝试运行

```
$ ./everybit -l
```

你会看到，即使在很小的缓冲区上进行几次旋转也需要很长时间才能运行。
你的任务是根据前面所述的规则，为 rotate_the_bit_vector() 提出一个更高效的实现。

**请注意，你只能修改submit_func.c文件。**

## 评分标准

本题中你需要提交**submit_func.c**文件，我们将使用你提交的文件替换原文件，再运行`module load  bisheng/2.5.0`加载编译器环境，然后运行`make`编译最终可执行程序`everybit`。
对应的三个测试算例将使用下述命令运行:
``` bash
./everybit -s # -s 算例
./everybit -m # -m 算例
./everybit -l # -l 算例
```
你的可执行程序将会运行在比赛集群上的一台机器的**1个核心**上，限制内存占用为**16G**。

| 算例  | 分数占比 | 满分层数 | 基础层数 |
| --- | ---- | ----| -----|
| -s  | 20% | 34 | 14 |
| -m  | 30% | 38 | 16 |
| -l  | 50% | 43 | 19 |

请注意， 请务必保证你的代码的正确性。我们将在多个算例下测试你的代码的正确性，<span style="color: red;">**若正确性测试未通过， 你会失去所有分数！**</span>


你可以使用自带的评测脚本`evaluate.py`测试你当前`source_code/everybit`路径下的代码的性能( 为保证测试的准确性，请确保你没有修改`submit_func.c`以外的其他文件 )，该脚本将打印出测试结果同时将结果输出到`result.yaml`中。

在通过正确性测试的情况下，每个算例的得分为
$$\min\{{\max\{{\frac{评分算例上你通过的层数 - 该算例基础层数}{该算例的满分层数 - 该算例基础层数},0}\}},1\} \times 100$$

你的总得分为各个算例的得分按照分数占比的加权平均值。
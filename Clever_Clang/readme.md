# Clever Clang
## 问题描述

梯度下降法是一种通过迭代调整参数以最小化目标函数的优化算法, 每次沿着梯度的负方向移动, 以找到函数的局部或全局最小值. 

在本题中, 你需要使用向量化指令的技术来实现梯度下降算法, 并对一个具有极值点的多项式函数进行优化. 具体流程包括：

1. 给定一个具有极值点的(至多四次的)多项式函数, 形如:

$$f(x) = a x^4 + b x^3 + c x^2 + d x$$

2. 在给定的搜索区间 $[a, b]$ 上等间隔采集 $N$ 个点作为初始值.

3. 对每个初始值点, 执行 $M$ 次梯度下降更新.梯度下降的更新规则为:

$$x_{k+1} = x_k - \eta \cdot \frac{\partial f(x)}{\partial x}$$

其中 $\eta$ 是更新步长, $\frac{\partial f(x)}{\partial x}$ 是目标函数的梯度.

4. 将每个初始值点的最终收敛位置保存到输出文件中.

我们已经提供了基本的代码框架, 你需要将核心的梯度下降更新部分代码`gd.cpp`使用向量化指令进行加速。**其他部分的代码不允许修改。**

## 输入输出格式

从输入文件 `conf.data` 中读取如下内容：

| 项目 | 类型 |
| --- | --- |
| `a` | 32 位浮点数 (搜索区间下界) |
| `b` | 32 位浮点数 (搜索区间上界) |
| `N` | 32 位整数 (等间隔采样点数) |
| `M` | 32 位整数 (每个点的梯度下降迭代次数) |
| `η` | 32 位浮点数 (更新步长) |
| `params` | 结构体 (四次多项式函数的各项系数) |


运行结果的输出代码已经给出, 请不要修改相关代码.

## 编译运行

在比赛提供的集群上, 请使用 `module load  bisheng/2.5.0` 加载 bisheng 编译器.

使用 `make` 进行编译. 

编译后, 用 `taskset -c 0-3 ./gd conf.data out.data` 将代码运行在集群机器的4个CPU核心上. 我们共有 5 个测试样例(`conf0.data`, `conf1.data`, ..., `conf4.data`). 其中样例 0 为 $f(x)=x^2$, 用于辅助你理解题意和程序逻辑, 不计入分数. 运行完成之后可将`out.data`与`ref.data`比较以验证你程序的正确性。

例如，可使用下述命令完成编译、运行`conf1.data`算例并检验正确性
```bash
# 假设此时已经位于source_code文件夹且加载好了编译器环境
make
taskset -c 0-3 ./gd conf1.data out1.data # 运行conf1.data算例并输出结果到out1.data
diff -q out1.data ref1.data # 比较输出文件与提供的参考文件的差异，如果该命令无输出则代表两个文件一致，正确性校验通过
```

> taskset -c 0-3 意味着将代码运行在机器的0,1,2,3核心上。实际上你可能并未申请到对应的核心，可以运行`python which_core.py`获取你当前申请到的核心编号，将0-3换成你对应的核心编号。
>
> 例如:如果`python which_core.py`输出为`get cores: [4, 5, 6, 7]`,则可以运行
>    ```
>    taskset -c 4-7 ./gd conf1.data out1.data # 运行conf1.data算例并输出结果到out1.data
>    ```

## 评分标准

**本题你需要提交`gd.cpp`文件**，我们会将你提交的`gd.cpp`替换原有的文件并使用如上指令运行你的程序, 在每个样例上先进行一次warm up，然后重复运行5次, 计算运行时间的平均值. 每个样例的输出会与参考输出进行比较, 以验证程序正确性. 单次样例运行有超时限制.

你的可执行程序将会运行在比赛集群上的一台机器的**4个核心**上，限制内存占用为**256G**。
| 算例  | 分数占比 | 满分时间(ms) | 基础时间(ms) |
| --- | ---- | ----| -----|
| 0 | 0% | 0 | 0 |
| 1 | 25% | 75 | 3000 |
| 2 | 25% | 75 | 3000 |
| 3 | 25% | 2500 | 20000 |
| 4 | 25% | 1000 | 6000 |

每个算例的分数计算公式为

$$\min(\max( \frac{满分时间*(基础时间-运行时间)}{运行时间*(基础时间-满分时间)},0),1) \times 100$$

## 评测脚本使用

我们提供了`evaluate.py`用于自测你当前的答题情况。直接运行
``` bash
python evaluate.py
```
将对你目前的答案进行评测，并输出你的得分。

默认情况下将会按照最终的评测标准进行测试，这将会让每个算例运行6次。如果你希望测试过程更快，可以添加参数`-t <num>`使得程序只会在warm up后运行`<num>`次，如果你希望不进行warm up，可以添加参数`--no-warmup`。但这都将导致结果可能不如最终评测准确。
例如
``` bash
python evaluate.py -t 1  # 在warm up后只运行一次算例
python evaluate.py --no-warmup -t 1 # 不进行warm up，只运行一次算例
```

## 提示

1. 比赛提供的集群支持NEON向量化指令集. 在`-O3`优化等级下, 编译器会自动尝试对核心代码进行向量化. 你可以使用 `clang++ -O3 -Rpass=vectorize gd.cpp main.cpp` 来检查向量化是否成功. 
2. 请不要修改 `main` 函数的内容
3. 使用初始代码运行 case 3,4 的时间较长, 直接进行评测可能会超时, 请在充分优化后再尝试运行.
4. 本试题将在22,23级提交通道关闭后在HPC入门指南上公布Hint, 在此之后提交此试题的得分将按原分数的60%计算。


